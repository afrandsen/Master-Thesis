---
title: "Langsigtet investering i aktier"
subtitle: |
       | En empirisk analyse af porteføljeallokering med rebalancering
       | # &#128201; &#10761; ? = &#128202;
author: "Andreas Kracht Frandsen"
date: "`r Sys.Date()`"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css:
      - default
      - default-fonts
      - "https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css"
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

class: animated, fadeIn

# Dagsorden
- Teoretiske resultater
 - Myopisk porteføljeallokering
 - Nytte over terminalformue
 - Afkastrelationer
 - Vector Autoregressive Process
 - Dynamisk porteføljeallokering
- Empirisk analyse
 - Kort om data
 - Normalitet
 - Stationaritet
 - Univariat analyse
 - Multipel analyse
 - Modelselektion
 - Endelig model
 - Allokering
 
Spørgsmål er velkomne undervejs, såfremt undertegnede kan besvare dem.

---

class: animated, fadeIn

# Fejlrettelser

130 sider + én mand = # mindre fejl

En række mindre fejl er blevet observeret af undertegnede.

 - Ift. multipel regression: Ikke vektor af fejlled.
 - Konfidensinterval ikke beskrevet på autokorrelationsplot.
 - Ligning for afkastrelation ift. kuponobligationer.
 - $x$-akse skulle ombyttes med $y$-akse på densitetsplot.

---

class: animated, fadeIn

# Kritik af opgave

De væsentligste kritikpunkter i afhandlingen var:
 - Analysen var på baggrund af en institutionel investor, og *ikke* en privat.
  - Dvs. menneskelig kapital og forbrug blev udeholdt.
 - Ingen test af robusthed på eksterne datasæt.
 - Kvartalsvise data anvendes.
  - Visse variable skabes som glidende gennemsnit.
 - Længde af dataperiode.
 - Transaktionsomkostninger udeholdt.
 - *Life-cycle* problem udeholdt.
 - Konstant *RRA* og konstant risiko over tid.
 - Gearingsomkostninger, skatter m.m.
 - VAR(1)-modellen valideres ikke.
  - Modellen kunne indeholde approksimationsfejl, da den bygger på approksimative analytiske løsninger.
 - Ingen performance-mæssig evaluering.
  - Ville en simpel $\tfrac{1}{n}$-portefølje klare sig bedre?
 - Datakvalitet?
  - Er data til at stole på?
 - Begrænset mængde af aktivklasser.
 - Sammenligning ift. en evt. benchmark model.
 - Kortsalgsrestriktionen sker ex-post.

Grundlæggende udgjorde afgrænsningerne de hovedsagelige kritikpunkter.

---

class: animated, fadeIn

# Vigtigste pointer



---

class: animated, fadeIn

# Teoretiske resultater

De kommende slides vil repræsenterer den præsenterede teori fra Del II.

Det forventes, at publikummet har *læst* det tidligere udsendte materiale.

Slides'ne vil derfor ikke være udtyndende.

---

class: animated, fadeIn

# Myopisk porteføljeallokering - &#128201;

Generelle (statiske) én-periode (Markowitz) problem

$$\max_{\alpha_t} \bf{\alpha}_t'(\mathbb{E}_t\left[\bf{R}_{t+1}\right]- R_{0,t+1}\bf{\ell}) - \frac{k}{2}\bf{\alpha}_t'\bf{\Sigma}_t\bf{\alpha}_t.$$

Lineær afvejning mellem forventede afkast og varians. $k$ fungerer som en skalering.

--

Har følgende løsning

$$\bf{\alpha}_t=\frac{1}{k}\bf{\Sigma}_t^{-1}(\mathbb{E}_t\left[\bf{R}_{t+1}\right]-R_{0,t+1}\bf{\ell}).$$

--

Nogen som sagde nytte? 	&#129300;

---

background-image: url("https://www.nobelprize.org/images/markowitz-13420-portrait-medium.jpg")
background-size: cover
class: animated, fadeIn

# <span style="color: white;">Myopisk porteføljeallokering - </span>&#128201;

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

<br>

Her er Harry forresten.

---

class: animated, fadeIn

# Nytte over terminalformue - &#128201;

I Sektion ?? blev nytten, $U(\cdot)$, defineret over terminalformue, $W_{t+1}$.

For at kvantificere risikoaversionen hørende til investorens konkave nyttefunktion blev *ARA* samt *RRA* benyttet.

Tre nyttefunktioner blev præsenteret:
 - Kvadratisk nytte
 - Eksponentiel nytte (*CARA*)
 - Potens nytte (*CRRA*)

Antagelsen om konstant *RRA* samt lognormale afkast var det afgørende element, da potens nytte blev valgt til videre brug.
 - Lognomale afkast er horisontinvariante	&#10003; 
 - *CRRA* under sekulær vækst	&#10003;
 - Lineærekombination i porteføljeafkast (løses ved brug af en approksimation) &#8274;

---

class: animated, fadeIn

# Afkastrelationer - &#128201;

Ud fra nutidsværdien af aktier og hhv. nulkuponobligationer samt kuponobligationer blev følgende relationer bl.a. udledt
$$d_t-p_t=\sum_{j=0}^\infty \rho^j \mathbb{E}_t\left[r_{t+j+1}-\Delta d_{t+j+1}\right]-\frac{c}{1-\rho},$$

$$r_{t+1}^n=n y_t^n - (n-1) y_{t+1}^{n-1},$$

$$r_{t+1}^{c,n}\approx D^{c,n} y_t^{c,n} - \left(D^{c,n} - 1\right) y_{t+1}^{c,n-1}=D^{c,n}(y_t^{c,n}- y_{t+1}^{c,n-1}) + y_{t+1}^{c,n-1}.$$

Disse gav anledning til, at der måtte eksistere en fundamental relation imellem visse variable:
 - Aktieafkast og udbytte
 - Obligationsafkast og rentespænd

Altså var forventningen til den univariate analyse herfra, at variable som inkorperer udbytte og rentespænd måtte have en statistisk signifikans i at prædiktere afkast.

---

class: animated, fadeIn

# Vector Autoregressive Process - &#128201;

VAR(1)-processen skulle benyttes til at skabe et dynamisk system for aktivernes afkast. Benyttelse af en sådan model, ville selvfølgelig kun være strengt nødvendig, i tilfældet hvor afkastene var *tidsvarierende*!

Systemet var fuldstændig defineret fra
$$\bf{z}_{t+1}=\bf{\Phi}_0+\bf{\Phi}_1\bf{z}_t+\bf{v}_{t+1}.$$

Herudover ville stabilitet- og stationaritetsbetingelsen være overholdt når
$$\det(\bf{\Phi}_1)\in(-1,1).$$

En lang række resultater blev udledt. Bias-justering i hældningskoefficienter blev ligeledes præsenteret. Denne bias var defineret som
$$\bf{B}_T=-\frac{\bf{b}}{T}+ O\left(T^{-\frac{3}{2}}\right),$$
 
og ville ligeledes give anledning til bias-justerede afskæringer.

???

Hvorfor ikke en restringeret 0 VAR-model?

---

class: animated, fadeIn

# Dynamisk porteføljeallokering - &#128201;

Herfra blev flere optimeringsproblemer præsenteret de var:

 - Én-periode *CRRA* problemet (uden tidsvarierende afkast).
 - $k$-periode *CRRA* problemet, uden tidsvarierende afkast.
  - Uden periodisk rebalancering.
  - Med periodisk rebalancering.
 - Det 'dynamiske' *CRRA* problem, med tidsvarierende afkast.

Disse blev vist for hhv. et setup med ét risikobærende aktiv samt setuppet med flere risikobærende aktiver.

---

class: animated, fadeIn

# Dynamisk porteføljeallokering - &#128201;

Nu vil undertegnede udlede den rekursive porteføljestrategi på tavlen.

---

class: animated, fadeIn

# Dynamisk porteføljeallokering - &#128201;

~~Nu vil undertegnede udlede den rekursive porteføljestrategi på tavlen.~~ 

--

Fandeme nej. 

Under *CRRA*-nytte, lognormale afkast og ikke mindst tidsvarierende afkast, blev det følgende porteføljeproblem beskrevet

$$\left\{\bf{\alpha}_{t+k-\tau}^\tau\right\}_{\tau=k}^{\tau=1}=
\arg\max\mathbb{E}_t\left[\frac{1}{1-\gamma}W_{t+k}^{1-\gamma}\right],\quad \gamma\neq 1,$$

$$\left\{\bf{\alpha}_{t+k-\tau}^\tau\right\}_{\tau=k}^{\tau=1}=\arg\max\mathbb{E}_t\left[\log(W_{t+k})\right],\quad \gamma=1.$$

Med tilhørende løsning

$$\bf{\alpha}_{t+k-\tau}^\tau = \frac{1}{\gamma} \bf{\Sigma}_{xx}^{-1} \left( \mathbb{E}_{t+k-\tau} \left[ \bf{r}_{t+k-\tau+1} - r_{0,t+k-\tau+1} \bf{\ell} \right] + \frac{1}{2} \bf{\sigma}_x^2 + (1-\gamma) \bf{\sigma}_{0x} \right)-\\ \quad\left(1-\frac{1}{\gamma} \right) \bf{\Sigma}_{xx}^{-1} \bf{\Sigma}_x \left(B_1^{\tau-1'}+(B_2^{\tau-1}+B_3^{\tau-1'})\mathbb{E}_{t+k-\tau}[\bf{z}_{t+k-\tau+1}]\right),$$

som kombinerer den én-periode myopiske portefølje og det *intertemporale hedging demand*. Udledningen af ovenstående findes i Appendiks C.

---

class: animated, fadeIn

# Dynamisk porteføljeallokering - &#128201;

En trunkering for at inkorporere en kortsalgsrestriktion blev ligeledes præsenteret
$$\alpha_{i,t}=\frac{\max(0,\alpha_{i,t})}{\sum_{i=1}^n \max(0,\alpha_{i,t})},$$

her skal selvfølgelig huskes på, at korrektionen er ex-post.

---

class: animated, fadeIn

# Empirisk analyse - &#128202;

De kommende slides vil repræsentere den empiriske analyse fra Del III.

Kort fortalt:
 - Få observationer.
 - Skæve fordelinger.
 - Ikke-normalitet.
 - Generelt stationære.
 - Høj absolut korrelation mellem variablene.
 - Lineær sammenhæng mellem visse variable, men ikke umiddelbart for de forventede variable.
 - Multipel regression viste, at meget lidt variation blev forklaret.
 - VAR model var stabil og stationær.
 - Allokering ændrer sig med investeringshorisont og risikotolerance.

---

class: animated, fadeIn

# Kort om data - &#128202;

En gennemgående databeskrivelse blev foretaget. Aktiverne bestod af hhv.:
 - Afkastet på en 90-dages amerikansk *T-Bill*.
 - Merafkastet på et indeks repræsenterende *NYSE*, *AMEX*, *NASDAQ* markederne.
 - Merafkastet på en 10-årige amerikansk statsobligation.
 - Merafkastet på et indeks repræsenterende virksomhedsobligationer.

Prædiktionsvariablene var:
 - *Dividend-Price Ratio*, *Price-Earnings Ratio*, *Book-to-Market Ratio*, aktievariansen, *Small Minus Big*, *High Minus Low*, den nominelle rente, *Term Spread*, *Yield Spread*, *Credit Spread*, *Default Spread* og *Federal Funds Rate*.

Dvs. mere end rigeligt til 259 kvartalsvise observationer!

???

Virksomhedsobligationsindekset?

---

class: animated, fadeIn

# Kort om data - &#128202;

```{r NET-TB-tids, echo=FALSE, fig.align='center', warning=FALSE, message=FALSE, fig.width=18, fig.height=4, dpi=300, cache=TRUE, fig.retina=3}

library(quantmod)
library(moments)
library(VAR.etp)
library(vars)
library(MASS)
library(tseries)
library(tidyverse)
library(latex2exp)

recessions.df = read.table(textConnection(
  "Peak, Trough
1857-06-01, 1858-12-01
1860-10-01, 1861-06-01
1865-04-01, 1867-12-01
1869-06-01, 1870-12-01
1873-10-01, 1879-03-01
1882-03-01, 1885-05-01
1887-03-01, 1888-04-01
1890-07-01, 1891-05-01
1893-01-01, 1894-06-01
1895-12-01, 1897-06-01
1899-06-01, 1900-12-01
1902-09-01, 1904-08-01
1907-05-01, 1908-06-01
1910-01-01, 1912-01-01
1913-01-01, 1914-12-01
1918-08-01, 1919-03-01
1920-01-01, 1921-07-01
1923-05-01, 1924-07-01
1926-10-01, 1927-11-01
1929-08-01, 1933-03-01
1937-05-01, 1938-06-01
1945-02-01, 1945-10-01
1948-11-01, 1949-10-01
1953-07-01, 1954-05-01
1957-08-01, 1958-04-01
1960-04-01, 1961-02-01
1969-12-01, 1970-11-01
1973-11-01, 1975-03-01
1980-01-01, 1980-07-01
1981-07-01, 1982-11-01
1990-07-01, 1991-03-01
2001-03-01, 2001-11-01
2007-12-01, 2009-06-01"), sep=',',
  colClasses=c('Date', 'Date'), header=TRUE)

recessions.trim = subset(recessions.df, Peak >= min(index(data)) )

# LOAD DATA.
input <- zoo::read.csv.zoo('C:/Users/AKF/Documents/Matematik-Okonomi/5. Ar/2. Semester/Master-Thesis/Input/Samling.csv', format = "%Y%m%d")

INF <- log(1+input$cpiret)
TB  <- log(1+input$t90ret)
NET_TB <- TB - INF
NET_TB_J <- NET_TB + (var(NET_TB, na.rm = TRUE)/2)
DATA_J <- data.frame(NET_TB_J)

data <- xts::xts(merge(NET_TB, TB), index(NET_TB))

knitr::opts_chunk$set(echo = FALSE,
                      dev = c("svg"))
knitr::opts_chunk$set(dev.args=list(bg="transparent"))

ggplot(data) +
  expand_limits(x = min(index(data)), y = min(data$NET_TB))+
  geom_line(aes(x=index(data), y=NET_TB)) +
  geom_rect(data=recessions.trim, aes(xmin=Peak, xmax=Trough, ymin=-Inf, ymax=+Inf), fill='pink', alpha=0.2)+
  coord_cartesian(ylim = c(min(data$NET_TB), max(data$NET_TB))) +
  scale_x_date(expand = c(0, 0), date_labels = "%Y", date_breaks = "2 year", limits = c(min(index(data)), max(index(data))))+
  scale_y_continuous(expand=c(0,0))+
  theme_bw()+
  theme(
    panel.grid.minor = element_blank()
  ) + 
  ylab(TeX("$r_{t}^{rf}$")) + 
  xlab("År")

a  <- acf(as.numeric(NET_TB), plot=FALSE)
ba <- with(a, data.frame(lag, acf))

conf_limits <- c(-1, 1) * qnorm((1 + 0.95) / 2) / sqrt(a$n.used)

ggplot(data = ba, mapping = aes(x = lag, y = acf)) +
  geom_hline(aes(yintercept = 0)) +
  geom_hline(yintercept = conf_limits, col = "pink") +
  geom_segment(mapping = aes(xend = lag, yend = 0)) +
  coord_cartesian(ylim = c(min(ba$acf)-0.1, 1)) +
  scale_y_continuous(expand=c(0,0))+
  scale_x_continuous(breaks = seq(0, 25, 1)) +
  theme_bw()+
  theme(
    panel.grid.minor = element_blank()
  ) + 
  ylab("AK") +
  xlab("Lag")

ggplot(data, aes(x = NET_TB)) +
  geom_histogram(aes(y=..density..), color="pink", fill = "pink", binwidth = 0.005, alpha = 0.4) +
  geom_density() +
  stat_function(fun = dnorm, colour = "red", args = list(mean = mean(DATA_J$NET_TB_J), sd = sqrt(var(data$NET_TB)))) + 
  geom_vline(data=DATA_J, aes(xintercept=mean(NET_TB_J)), linetype="dashed", color ="red") +
  expand_limits(x = 0, y = 0)+
  coord_cartesian(ylim = c(0, ceiling(max(density(data$NET_TB)$y)))) +
  scale_y_continuous(expand=c(0,0))+
  theme_bw()+
  theme(
    panel.grid.minor = element_blank()
  )  +
   ylab(TeX("$r_{t}^{rf}$")) +
  xlab("Densitet")
```

---

class: animated, fadeIn

# Kort om data - &#128202;

Der blev lavet beskrivende statistik. Først for aktivklasserne.

```{r, fig.retina=3, echo=FALSE, fig.align="center"}
knitr::include_graphics("C:/Users/AKF/Downloads/STAT.png")
```


???

Justeret middelværdi?

---

class: animated, fadeIn

# Kort om data - &#128202;

Dernæst for prædiktionsvariablene.

```{r, fig.retina=3, echo=FALSE, fig.align="center"}
knitr::include_graphics("C:/Users/AKF/Downloads/STAT_T.png")
```

---

class: animated, fadeIn

# Korrelation - &#128202;

Korrelationen mellem alle variable.

```{r, fig.retina=3, echo=FALSE, fig.align="center"}
knitr::include_graphics("C:/Users/AKF/Downloads/KORR.png")
```

---

class: animated, fadeIn

# Normalitet - &#128202;

På trods af de relativt få observationer, blev normalitetsbetingelsen alligevel tjekket.

Først for aktivklasserne.

```{r, fig.retina=3, echo=FALSE, fig.align="center"}
knitr::include_graphics("C:/Users/AKF/Downloads/JB.png")
```

--

Bliver forkastet med et brag som forventet.

???

Hvorfor så fortsætte analysen?

---

class: animated, fadeIn

# Normalitet - &#128202;

Dernæst for prædiktionsvariablene.

```{r, fig.retina=3, echo=FALSE, fig.align="center"}
knitr::include_graphics("C:/Users/AKF/Downloads/JB_T.png")
```

--

*Small Minus Big* faktoren udviser meget normalitetslighed! Cadeau til Fama og French.

---


class: animated, fadeIn

# Stationaritet - &#128202;

Stationaritetsbetingelsen blev ligeledes undersøgt for hver tidsserie. *Augmented Dickey-Fuller* blev først præsenteret.

```{r, fig.retina=3, echo=FALSE, fig.align="center"}
knitr::include_graphics("C:/Users/AKF/Downloads/ADF.png")
```

???

Hvorfor ikke anvende de første forskelle på visse variable?

---

class: animated, fadeIn

# Univariat analyse - &#128202;

Den univariate analyse havde til opgave at finde evt. lineære sammenhænge mellem responsen (merafkast) og prædiktionsvariablene.

```{r, fig.retina=3, echo=FALSE, fig.align="center"}
knitr::include_graphics("C:/Users/AKF/Downloads/UNI_A.png")
```

---

class: animated, fadeIn

# Multipel analyse - &#128202;

Den multiple analyse havde til formål at formindske bias ved inklusion af flere variable.

```{r, fig.retina=3, echo=FALSE, fig.align="center"}
knitr::include_graphics("C:/Users/AKF/Downloads/MULT_A.png")
```

Regressionens ulempe er multikollinearitet.

???

Hvorfor ikke anvende interaktion?

---

class: animated, fadeIn

# Multipel analyse - &#128202;

Modeltjek blev ligeledes foretaget, her var enkelte observationer generelt *outliers* på tværs af alle de multiple regressioner.

```{r, fig.retina=3, echo=FALSE, fig.align="center"}
knitr::include_graphics("C:/Users/AKF/Downloads/AUTO_A.png")
```

---

class: animated, fadeIn

# Modelselektion - &#128202;

Modelselektionen blev foretaget via en *Step-AKFIC*-procedure. Her blev hver VAR(1)-ligning trinvist optimeret.

Der var få krav til selektionen:
 - Den nominelle rente skulle inkluderes for at medtage inflation i systemet
 - Samtlige aktiver skulle forklare variationen på tværs af alle aktiver og prædiktionsvariable.

Derudover blev to VIF-analyse foretaget, som skulle afhjælpe multikollinearitet. For at have en balanceret model, blev en kvalititativ beslutning ligeledes taget.

???

Hvorfor ikke AIC?

Hvorfor ikke forward selection?

Hvorfor betingelserne?

Hvorfor kvalitativ udvægelse?

---

class: animated, fadeIn

# Modelselektion - &#128202;

```{r, fig.retina=3, echo=FALSE, fig.align="center"}
knitr::include_graphics("C:/Users/AKF/Downloads/MOD_A.png")
```

---

class: animated, fadeIn

# Modelselektion - &#128202;

```{r, fig.retina=3, echo=FALSE, fig.align="center"}
knitr::include_graphics("C:/Users/AKF/Downloads/VIF.png")
```

---

class: animated, fadeIn

# Endelig model - &#128202;

Efter modelselektionen blev den restringerede VAR(1)-model estimeret. Den endelige model bestod af de fire aktiver samt fire prædiktionsvariable.

```{r, fig.retina=3, echo=FALSE, fig.align="center"}
knitr::include_graphics("C:/Users/AKF/Downloads/VAR.png")
```

???

Hvorfor reageres ikke på insignifikante variable?

---

class: animated, fadeIn

# Endelig model - &#128202;

Fejlledenes korrelationsmatrix sammenholdt med koefficientestimaterne gav en indikation af den mulige *mean reversion*/*mean aversion* blandt variablene.

```{r, fig.retina=3, echo=FALSE, fig.align="center"}
knitr::include_graphics("C:/Users/AKF/Downloads/VAR_F.png")
```


---

class: animated, fadeIn

# Monte Carlo studie - &#128202;

Dette kapitel fungerede som et modspil til afsnittene om afkastprædiktabilitet.

```{r weight-exp, echo=FALSE, fig.align='center', warning=FALSE, message=FALSE, fig.width=18, fig.height=8, dpi=300, cache=TRUE, fig.retina=3}
library(IntroCompFinR)
library(tidyverse)

set.seed(1)

mu_a <- 0.0225
mu_b <- 0.0394
mu_c <- 0.0128

rf <- 0.00125

return <- rbind(mu_a, mu_b, mu_c)

std_a <- 0.10347
std_b <- 0.12899
std_c <- 0.08660

std <- rbind(std_a, std_b, std_c)

corr <- matrix(c(1, 0.500, 0.500, 0.500, 1, 0.500, 0.500, 0.500, 1), nrow = 3)
cov <- sweep(sweep(corr, 1L, c(std_a,std_b,std_c), "*"), 2L, c(std_a,std_b,std_c), "*")


calc.portfolio <- function(r, cov, rf, a = c(1, 4, 8)){
  port <- list()
  
  gmv <- globalMin.portfolio(r, cov)
  
  tan <- tangency.portfolio(r, cov, rf)
  
  port[['gmv']] <- gmv
  port[['tan']] <- tan
  
  cara    <- matrix(0, nrow = length(a), ncol = length(c(r, rf)))
  cara_r  <- c()
  cara_sd <- c()
  
  crra    <- matrix(0, nrow = length(a), ncol = length(c(r, rf)))
  crra_r  <- c()
  crra_sd <- c()
  
  for (i in seq_along(a)) {
    cara[i, ]  <- c(tan$weights*(tan$er-rf)/(a[i]*tan$sd^2), 1-(tan$er-rf)/(a[i]*tan$sd^2))
    
    cara_r[i]  <- sum(cara[i, ] * c(r, rf))
    
    cara_sd[i] <- sqrt(t(cara[i, 1:length(r)]) %*% cov %*% cara[i, 1:length(r)])
    
    port[[paste('cara', a[i], sep = '_')]] <- list("er" = as.vector(cara_r[i]),
                                                   "sd" = as.vector(cara_sd[i]),
                                                   "weights" = cara[i,])
    crra[i, ] <- c((1/a[i]) * solve(cov) %*% (r - c(rf, rf, rf) + diag(cov) / 2), 1 - sum((1/a[i]) * solve(cov) %*% (r - c(rf, rf, rf) + diag(cov) / 2)))
    
    #crra[i, ] <- c((r - rf + (diag(cov)/2))/(a[i]*diag(cov)), 1 - sum((r - rf + (diag(cov)/2))/(a[i]*diag(cov))))
  
    crra_r[i]  <- sum(crra[i, ] * c(r, rf))
    
    crra_sd[i] <- sqrt(t(crra[i, 1:length(r)]) %*% cov %*% crra[i, 1:length(r)])
    
    port[[paste('crra', a[i], sep = '_')]] <- list("er" = as.vector(crra_r[i]),
                                                   "sd" = as.vector(crra_sd[i]),
                                                   "weights" = crra[i,])
  }
  
  return(port)
  
}


sim <- function(mu_a, mu_b, mu_c, std_a, std_b, std_c){
  e1 <- rnorm(1)
  e2 <- rnorm(1)
  e3 <- rnorm(1)
  
  r_a <- mu_a+std_a*e1
  r_b <- mu_b+std_b*(corr[, 2][1]*e1+sqrt(1-corr[, 2][1]^2)*e2)
  r_c <- mu_c + std_c * (corr[, 1][3] * e1 + ( (corr[, 2][3] - corr[, 1][2] * corr[, 1][3]) / (sqrt(1 - corr[, 1][2]^2)) ) * e2 + sqrt(1 - corr[, 1][3]^2 - ( (corr[, 2][3] - corr[, 1][2] * corr[, 1][3])^2 / (1- corr[, 1][2]^2) ) ) * e3)
  
  return(c(r_a, r_b, r_c))
}

data_1 <- t(matrix(replicate(200, sim(mu_a, mu_b, mu_c, std_a, std_b, std_c)), nrow = 3))
data_2 <- t(matrix(replicate(200, sim(mu_a, mu_b, mu_c, std_a, std_b, std_c)), nrow = 3))
data_3 <- t(matrix(replicate(200, sim(mu_a, mu_b, mu_c, std_a, std_b, std_c)), nrow = 3))

data_1_mean <- colMeans(data_1)
data_1_sd <- apply(data_1, 2, sd)
data_1_cor <- cor(data_1)
data_1_cov <- cov(data_1)

data_2_mean <- colMeans(data_2)
data_2_sd <- apply(data_2, 2, sd)
data_2_cor <- cor(data_2)
data_2_cov <- cov(data_2)

data_3_mean <- colMeans(data_3)
data_3_sd <- apply(data_3, 2, sd)
data_3_cor <- cor(data_3)
data_3_cov <- cov(data_3)

port_true <- calc.portfolio(return, cov, rf)
port_1    <- calc.portfolio(data_1_mean, data_1_cov, rf)
port_2    <- calc.portfolio(data_2_mean, data_2_cov, rf)
port_3    <- calc.portfolio(data_3_mean, data_3_cov, rf)





combine <- function(port){
  r <- c(port$gmv$er, port$tan$er, port$crra_1$er, port$crra_4$er, port$crra_8$er, port$cara_1$er, port$cara_4$er, port$cara_8$er)
  sd <- c(port$gmv$sd, port$tan$sd, port$crra_1$sd, port$crra_4$sd, port$crra_8$sd, port$cara_1$sd, port$cara_4$sd, port$cara_8$sd)
  
  return(matrix(c(r, sd), ncol = 2))
}

combine_sim <- function(port, return, rf, cov){
  r <- c(sum(port$gmv$weights*return),
         sum(port$tan$weights*return),
         sum(port$crra_1$weights*c(return, rf)),
         sum(port$crra_4$weights*c(return, rf)),
         sum(port$crra_8$weights*c(return, rf)),
         sum(port$cara_1$weights*c(return, rf)),
         sum(port$cara_4$weights*c(return, rf)),
         sum(port$cara_8$weights*c(return, rf)))
  sd <- c(sqrt(t(port$gmv$weights[1:3]) %*% cov %*% port$gmv$weights[1:3]),
          sqrt(t(port$tan$weights[1:3]) %*% cov %*% port$tan$weights[1:3]),
          sqrt(t(port$crra_1$weights[1:3]) %*% cov %*% port$crra_1$weights[1:3]),
          sqrt(t(port$crra_4$weights[1:3]) %*% cov %*% port$crra_4$weights[1:3]),
          sqrt(t(port$crra_8$weights[1:3]) %*% cov %*% port$crra_8$weights[1:3]),
          sqrt(t(port$cara_1$weights[1:3]) %*% cov %*% port$cara_1$weights[1:3]),
          sqrt(t(port$cara_4$weights[1:3]) %*% cov %*% port$cara_4$weights[1:3]),
          sqrt(t(port$cara_8$weights[1:3]) %*% cov %*% port$cara_8$weights[1:3]))
  
  return(matrix(c(r, sd), ncol = 2))
}

r <- combine(port_true)[, 1]
r_1 <- combine_sim(port_1, return, rf, cov)[, 1]
r_2 <- combine_sim(port_2, return, rf, cov)[, 1]
r_3 <- combine_sim(port_3, return, rf, cov)[, 1]

sd <- combine(port_true)[, 2]
sd_1 <- combine_sim(port_1, return, rf, cov)[, 2]
sd_2 <- combine_sim(port_2, return, rf, cov)[, 2]
sd_3 <- combine_sim(port_3, return, rf, cov)[, 2]

data <- data.frame(sd=c(sd, sd_1, sd_2, sd_3), r = c(r, r_1, r_2, r_3), type = c(rep("Sande momenter", 8), rep("1. Simulering", 8), rep("2. Simulering", 8), rep("3. Simulering", 8)))

ggplot(data, aes(sd, r)) +
  geom_point(aes(color = factor(type),
                 group = factor(type),
                 shape = factor(type),
                 size = factor(type))) +
  geom_line(aes(color = factor(type),
                group = factor(type),
                linetype=factor(type))) +
  expand_limits(x = 0, y = 0) +
  xlab("Volatilitet") +
  ylab("Forventet afkast") +
  coord_cartesian(ylim = c(min(data$r)-0.0003,
                           max(data$r)+0.010),
                  xlim = c(min(data$sd)-0.001,
                           max(data$sd)+0.015)) +
  scale_x_continuous(expand = c(0,0),
                     minor_breaks = seq(0, 0.5, 0.05),
                     breaks = c(0.025, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45),
                     trans = "log10") +
  scale_y_continuous(expand = c(0,0),
                     minor_breaks = seq(0 , 0.15, 0.025),
                     breaks = c(0.01, 0.025, 0.05, 0.075, 0.1, 0.125, 0.15),
                     trans = "log10") +
  theme_bw() +
  scale_colour_brewer(palette = "Dark2") +
  scale_linetype_manual(values=c("solid", "dashed", "dotted", "twodash")) +
  scale_shape_manual(values=c(15, 16, 17, 18)) +
  scale_size_manual(values=c(3, 3, 3, 3)) +
  theme(
    legend.background = element_rect(fill = "white",
                                     linetype="solid",
                                     size = 0.1,
                                     colour = "black"),
    legend.position="bottom",
    legend.key.size = unit(4, "line"),
    legend.title = element_blank(),
    legend.text=element_text(size = 20)
  ) +
  labs(color = "Grundlag",
       linetype = "Grundlag",
       shape = "Grundlag",
       size = "Grundlag")
```

Her blev påvist gennem simulation, hvordan præcisionen i momentestimaterne kan påvirke porteføljeallokeringerne. Dette var på baggrund af fuld information om den bagvedliggende fordeling af tidsserierne.

---

class: animated, fadeIn

# Allokering - &#128202;

*First-period* allokeringer, dvs. for $A_0^{t+k}$, $A_1^{t+k}$, altså hvor den resterende horisontlængde er $t+k$.

Investoren har horisont på $25$ år og en moderat risikoaversion $\gamma=5$.

```{r, echo=FALSE, fig.align='center', warning=FALSE, message=FALSE, fig.width=18, fig.height=8, dpi=300, cache=TRUE, fig.retina=3}
library(quantmod)
library(moments)
library(VAR.etp)
library(vars)
library(MASS)
library(tseries)
library(tidyverse)
library(latex2exp)
library(kableExtra)

# LOAD DATA.
input <- zoo::read.csv.zoo('C:/Users/AKF/Documents/Matematik-Okonomi/5. Ar/2. Semester/Master-Thesis/Input/Samling.csv', format = "%Y%m%d")
#input <- as.xts(input)

# MANIPULATING DATA.

# AKTIVKLASSER
INF <- log(1+input$cpiret)
TB  <- log(1+input$t90ret)
NET_TB <- TB - INF
AKT    <- log(1 + input$vwretd) - TB
S_OBL  <- log(1 + input$b10ret) - TB
V_OBL  <- log(1 + input$corpr) - TB

# FINANSIELLE INDIKATORER
DP <- input$dp
EP <- log(as.numeric(input$vwindx)) - log(input$earn)

BM <- input$bm
AKT_VAR <- log(1 + input$svar)
SMB <- input$smb
HML <- input$hml
EP_J <- EP + (var(EP, na.rm = TRUE)/2)
DP_J <- DP + (var(DP, na.rm = TRUE)/2)


# TERM STRUCTURE
T_SPREAD <- input$t10y/100 - input$t90y/100
Y_SPREAD <- input$t5y/100 - input$t90y/100
C_SPREAD <- input$baa/100 - input$t90y/100
D_SPREAD <- input$baa/100 - input$aaa/100

# MAKROØKONOMISKE 
FR <- input$fedfund/100

# JUSTERING

TB_J     <- TB + (var(TB, na.rm = TRUE)/2)
NET_TB_J <- NET_TB + (var(NET_TB, na.rm = TRUE)/2)
AKT_J    <- AKT + (var(AKT, na.rm = TRUE)/2)
S_OBL_J  <- S_OBL + (var(S_OBL, na.rm = TRUE)/2)
V_OBL_J  <- V_OBL + (var(V_OBL, na.rm = TRUE)/2)

# BESKRIVENDE STATISTIK

## AKTIVKLASSER
DATA <- data.frame(NET_TB, AKT, S_OBL, V_OBL)
DATA_J <- data.frame(NET_TB_J, AKT_J, S_OBL_J, V_OBL_J)

ADJ_DATA_MEAN <- colMeans(DATA_J)
DATA_STD <- apply(DATA, 2, sd)
DATA_QUANTILE <- apply(DATA, 2, quantile)
DATA_SKEWNESS <- apply(DATA, 2, skewness)
DATA_KURTOSIS <- apply(DATA, 2, kurtosis)

DESCRIPTIVE <- data.frame(adj_mean=ADJ_DATA_MEAN,
                          sd=DATA_STD,
                          sr=ADJ_DATA_MEAN/DATA_STD,
                          skew=DATA_SKEWNESS,
                          kurt=DATA_KURTOSIS,
                          quantile=t(DATA_QUANTILE),
                          ac=unlist(lapply(1:ncol(DATA), function(x) acf(DATA[,x], plot = FALSE, lag.max = 1)$acf))[c(rep(FALSE,1),TRUE)])
DESCRIPTIVE$sr[1] <- NA

JB <- data.frame(teststat = unlist(lapply(1:ncol(DATA), function(x) jarque.bera.test(DATA[,x])$statistic)),
                 p = unlist(lapply(1:ncol(DATA), function(x) jarque.bera.test(DATA[,x])$p.value)))

## TILSTANDSVARIABLE
DATA_T <- xts::xts(merge(DP, EP, BM, AKT_VAR, HML, SMB, TB, T_SPREAD, Y_SPREAD, C_SPREAD, D_SPREAD, FR), index(TB))

DATA_T_J <- xts::xts(merge(DP_J, EP_J, TB_J), index(TB_J))

ADJ_DATA_T_MEAN <- colMeans(DATA_T_J)
DATA_T_MEAN <- colMeans(DATA_T)
DATA_T_STD <- apply(DATA_T, 2, sd)
DATA_T_QUANTILE <- apply(DATA_T, 2, quantile)
DATA_T_SKEWNESS <- apply(DATA_T, 2, skewness)
DATA_T_KURTOSIS <- apply(DATA_T, 2, kurtosis)

DESCRIPTIVE_T <- data.frame(mean=DATA_T_MEAN,
                          sd=DATA_T_STD,
                          skew=DATA_T_SKEWNESS,
                          kurt=DATA_T_KURTOSIS,
                          quantile=t(DATA_T_QUANTILE),
                          ac=unlist(lapply(1:ncol(DATA_T), function(x) acf(DATA_T[,x], plot = FALSE, lag.max = 1)$acf))[c(rep(FALSE,1),TRUE)])


DESCRIPTIVE_T$mean[1:2] <- ADJ_DATA_T_MEAN[1:2]
DESCRIPTIVE_T$mean[7] <- ADJ_DATA_T_MEAN[3]

JB_T <- data.frame(teststat = unlist(lapply(1:ncol(DATA_T), function(x) jarque.bera.test(DATA_T[,x])$statistic)),
                 p = unlist(lapply(1:ncol(DATA_T), function(x) jarque.bera.test(DATA_T[,x])$p.value)))

# STATIONARITET
data <- xts::xts(merge(NET_TB, AKT, S_OBL, V_OBL, DP, EP, BM, AKT_VAR, HML, SMB, TB, T_SPREAD, Y_SPREAD, C_SPREAD, D_SPREAD, FR), index(NET_TB))

# VAR

data <- xts::xts(merge(NET_TB, AKT, S_OBL, V_OBL, DP, EP, BM, AKT_VAR, HML, SMB, TB, T_SPREAD, Y_SPREAD, C_SPREAD, D_SPREAD, FR), index(NET_TB))

## RISIKOFRI
data_var_rf <- as.xts(merge(xts::lag.xts(data$NET_TB, -1, na.pad = FALSE), head(data, -1)))

fit_var_rf  <- lm(NET_TB ~ NET_TB.1 + AKT + S_OBL + V_OBL + DP + EP + BM + AKT_VAR + HML + SMB + TB + T_SPREAD + Y_SPREAD + C_SPREAD + D_SPREAD + FR, data=data_var_rf)

step_var_rf_model <- step(fit_var_rf, k = qchisq(0.05,df = 1, lower.tail = F), scope = list(lower=NET_TB ~ NET_TB.1 + AKT + S_OBL + V_OBL + TB, upper=fit_var_rf), trace = 0)

prod_var_rf <- lm(NET_TB ~ NET_TB.1 + AKT + S_OBL + V_OBL + BM + SMB + TB + Y_SPREAD, data=data_var_rf)

step_table_rf <- data.frame(dp=c(-2516.1, -2519.7, -2523.5, -2525.3, NA),
                            pe=c(-2520.2, NA, NA, NA, NA),
                            bm=c(-2497.1, -2499.3, -2502.5, -2505.2, -2499.1),
                            avar=c(-2515.0, -2518.0, -2521.5, -2520.9,  -2522.5),
                            hml=c(-2517.7, -2521.5, -2525.0, NA, NA),
                            smb=c(-2513.6, -2517.3, -2521.0, -2522.7, -2521.7),
                            ts=c(-2519.7, -2523.5, NA, NA, NA),
                            ys=c(-2514.8, -2518.7, -2514.5, -2516.3, -2510.2),
                            cs=c(-2517.9, -2521.7, -2511.8, -2514.2, -2507.9),
                            ds=c(-2503.7, -2507.5, -2495.9, -2498.9, -2497.0),
                            fr=c(-2516.4, -2520.2, -2523.7, -2525.1, -2524.7))
step_table_rf <- cbind(min=apply(step_table_rf, 1, FUN=min, na.rm=TRUE), step_table_rf)


## AKTIER
data_var_akt <- as.xts(merge(xts::lag.xts(data$AKT, -1, na.pad = FALSE), head(data, -1)))

fit_var_akt  <- lm(AKT ~ NET_TB + AKT.1 + S_OBL + V_OBL + DP + EP + BM + AKT_VAR + HML + SMB + TB + T_SPREAD + Y_SPREAD + C_SPREAD + D_SPREAD + FR, data=data_var_akt)

step_var_akt_model <- step(fit_var_akt, k = qchisq(0.05,df = 1, lower.tail = F), scope = list(lower=AKT ~ NET_TB + AKT.1 + S_OBL + V_OBL + TB, upper=fit_var_akt), trace = 0)

prod_var_akt <- lm(AKT ~ NET_TB + AKT.1 + S_OBL + V_OBL + BM + SMB + TB + Y_SPREAD, data=data_var_akt)

step_table_akt <- data.frame(dp=c(-1264.3, NA, NA, NA, NA, NA, NA, NA, NA),
                            pe=c(-1264.0, -1267.7, -1271.3, NA, NA, NA, NA, NA, NA),
                            bm=c(-1264.1, -1267.3, -1269.8, -1269.4, -1271.3, -1271.7, -1272.7,-1271.8,  -1275.1 ),
                            avar=c(-1262.8, -1266.5, -1269.8,-1273.5, NA, NA, NA, NA, NA ),
                            hml=c(-1262.3, -1266.0, -1269.6,-1272.9, -1274.0, NA, NA, NA, NA ),
                            smb=c(-1259.4,-1263.0, -1266.5, -1269.7,  -1272.5, -1272.8,-1272.2, -1273.5, -1276.4 ),
                            ts=c(-1260.2,-1263.1, -1266.0, -1268.7, -1271.7, -1273.2, -1276.3, NA, NA ),
                            ys=c(-1261.3, -1264.9, -1268.7, -1271.6, -1273.9, -1274.9, NA, NA, NA),
                            cs=c(-1261.8, -1264.5, -1264.2, -1266.7, -1270.5, -1272.3,-1275.9, -1279.8, NA ),
                            ds=c( -1264.2,  -1267.9, NA, NA, NA, NA, NA, NA, NA),
                            fr=c(-1258.8, -1262.4, -1266.1,-1269.5, -1272.2, -1272.8, -1274.0, -1272.1, -1275.5))
step_table_akt <- cbind(min=apply(step_table_akt, 1, FUN=min, na.rm=TRUE), step_table_akt)

## STATS
data_var_s <- as.xts(merge(xts::lag.xts(data$S_OBL, -1, na.pad = FALSE), head(data, -1)))

fit_var_s  <- lm(S_OBL ~ NET_TB + AKT + S_OBL.1 + V_OBL + DP + EP + BM + AKT_VAR + HML + SMB + TB + T_SPREAD + Y_SPREAD + C_SPREAD + D_SPREAD + FR, data=data_var_s)

step_var_s_model <- step(fit_var_s, k = qchisq(0.05,df = 1, lower.tail = F), scope = list(lower=S_OBL ~ NET_TB + AKT + S_OBL.1 + V_OBL + TB, upper=fit_var_s), trace = 0)

prod_var_s <- lm(S_OBL ~ NET_TB + AKT + S_OBL.1 + V_OBL + BM + SMB + TB + Y_SPREAD, data=data_var_s)

step_table_s <- data.frame(dp=c(-1710.4,-1714.2,  -1717.8, -1721.7, -1721.9, -1725.8, NA ),
                             pe=c(-1711.0, -1714.8, -1718.6,-1722.2, NA, NA, NA  ),
                             bm=c(-1711.9,-1715.7, NA, NA, NA, NA, NA ),
                             avar=c(-1705.2,-1708.9, -1712.6, -1716.3, -1717.0, -1717.9, -1720.2 ),
                             hml=c( -1712.1, NA, NA, NA, NA, NA, NA),
                             smb=c(-1708.0, -1711.7, -1714.9,-1718.7, -1721.7, -1723.9,  -1725.1 ),
                             ts=c(-1711.9, -1715.7, -1719.2,  NA, NA, NA, NA),
                             ys=c(-1707.8,-1711.6,  -1715.1,-1694.6,-1695.9,  -1691.6,-1695.2  ),
                             cs=c(-1702.1, -1705.9, -1709.3,-1696.9, -1699.6, -1681.0, -1684.1 ),
                             ds=c(-1711.0,-1714.8, -1718.1, -1721.9, -1724.8, NA, NA ),
                             fr=c(-1687.6,-1691.4,  -1694.2, -1697.9, -1701.3,-1702.7, -1704.9  ))
step_table_s <- cbind(min=apply(step_table_s, 1, FUN=min, na.rm=TRUE), step_table_s)

## VIRKSOMHEDER
data_var_v <- as.xts(merge(xts::lag.xts(data$V_OBL, -1, na.pad = FALSE), head(data, -1)))

fit_var_v  <- lm(V_OBL ~ NET_TB + AKT + S_OBL + V_OBL.1 + DP + EP + BM + AKT_VAR + HML + SMB + TB + T_SPREAD + Y_SPREAD + C_SPREAD + D_SPREAD + FR, data=data_var_v)

step_var_v_model <- step(fit_var_v, k = qchisq(0.05,df = 1, lower.tail = F), scope = list(lower=V_OBL ~ NET_TB + AKT + S_OBL + V_OBL.1 + TB, upper=fit_var_v), trace = 0)

prod_var_v <- lm(V_OBL ~ NET_TB + AKT + S_OBL + V_OBL.1 + BM + SMB + TB + Y_SPREAD, data=data_var_v)

step_table_v <- data.frame(dp=c(-1607.8, -1611.5, -1615.4, -1618.2,-1620.0, -1623.1,NA ),
                             pe=c(-1608.6, -1612.4, NA, NA, NA, NA, NA),
                             bm=c(-1608.6, -1612.4,  -1616.2, NA, NA ,NA , NA),
                             avar=c(-1603.4, -1607.3, -1610.8,  -1614.5, -1618.4, -1619.8, -1621.2),
                             hml=c( -1607.6, -1611.5, -1615.3, -1619.1,-1622.8, NA, NA ),
                             smb=c(-1603.0, -1606.7,-1610.6,  -1614.2, -1618.0, -1621.1, -1621.4),
                             ts=c(-1608.6, NA, NA, NA, NA, NA, NA),
                             ys=c(-1606.7,-1604.2, -1607.8, -1611.6, -1607.3, -1610.6, -1614.2 ),
                             cs=c(-1605.8, -1602.3, -1606.1,-1609.8,  -1590.1, -1593.0,  -1596.7 ),
                             ds=c(-1608.4,-1612.2, -1616.0, -1619.8, NA, NA, NA ),
                             fr=c(-1584.4,-1588.2,  -1592.0, -1595.4,-1599.2,   -1602.2,-1603.8  ))
step_table_v <- cbind(min=apply(step_table_v, 1, FUN=min, na.rm=TRUE), step_table_v)

data_v <- as.ts(data)
# 
data_sub <- subset(data_v, select = -c(DP, EP, AKT_VAR, HML, T_SPREAD, C_SPREAD, D_SPREAD, FR))
# 
var <- VAR(data_sub, p = 1)
var.p <- VAR.Pope(data_sub, p = 1)

coef <- Bcoef(var)

coef1 <- coef(var)
cov <- summary(var)$covres
cor <- summary(var)$corres

test <- summary(var)

roots <- roots(var)

VAR_TABLE <- data.frame(coef,
                        rsq=unlist(lapply(1:8, function(x) test$varresult[[x]]$adj.r.squared)))

VAR_TABLE <- format(round(VAR_TABLE, digits = 3), nsmall = 3)

for (j in c(1:8)) {
  for (i in c(1:9)){
    if (abs(test$varresult[[j]]$coefficients[,3][i])>=qnorm(0.975)) {
      VAR_TABLE[j,i] <- paste0("\\textbf{", VAR_TABLE[j,i],"}")
    }
    
  }
}

j <- 0

for (i in c(1:8)) {

  VAR_TABLE <- rbind(VAR_TABLE[(1):(1+j),],
                     format(round(var.p$coef[i,],3), nsmall = 3),
                     VAR_TABLE[-(1:(1+j)),])

  VAR_TABLE <- rbind(VAR_TABLE[1:(2+j),],
                     format(round(test$varresult[[i]]$coefficients[,3],3), nsmall = 3),
                     VAR_TABLE[-(1:(2+j)),])

  j <- j + 3
}

j <- 1

for (i in seq(2,23,3)) {
  
  VAR_TABLE[i, 10] <- format(round(test$varresult[[j]]$fstatistic[1], 3), nsmall = 3)
  
  j <- j + 1
}

for (i in seq(1,24,3)){

VAR_TABLE[i+1,1:9] <- gsub("\\s", "", paste0("(", VAR_TABLE[i+1,], ")"))

VAR_TABLE[i+2,1:9] <- gsub("\\s", "", paste0("[", VAR_TABLE[i+2,], "]"))

VAR_TABLE[i+1,10] <- gsub("\\s", "", paste0("$\\langle", VAR_TABLE[i+1,10], "\\rangle$"))

}

VAR_TABLE <- cbind(NAME=c("$r_t^{\\text{rf}}$","","", "$rx_t^{\\text{a}}$","","", "$rx_t^{\\text{s}}$","","", "$rx_t^{\\text{v}}$","","", '$x_t^{\\text{bm}}$',"","", '$x_t^{\\text{smb}}$',"","", '$x_t^{\\text{b}}$',"","", '$x_t^{\\text{ys}}$',"",""), VAR_TABLE)

VAR_TABLE <- VAR_TABLE[,c(1,10,2,3,4,5,6,7,8,9,11)]

for (i in seq(1,24,3)){
  
  VAR_TABLE[i+2,11] <- NA
}

coef <- var.p$coef
cov <- var.p$sigu

recessions.df = read.table(textConnection(
  "Peak, Trough
1857-06-01, 1858-12-01
1860-10-01, 1861-06-01
1865-04-01, 1867-12-01
1869-06-01, 1870-12-01
1873-10-01, 1879-03-01
1882-03-01, 1885-05-01
1887-03-01, 1888-04-01
1890-07-01, 1891-05-01
1893-01-01, 1894-06-01
1895-12-01, 1897-06-01
1899-06-01, 1900-12-01
1902-09-01, 1904-08-01
1907-05-01, 1908-06-01
1910-01-01, 1912-01-01
1913-01-01, 1914-12-01
1918-08-01, 1919-03-01
1920-01-01, 1921-07-01
1923-05-01, 1924-07-01
1926-10-01, 1927-11-01
1929-08-01, 1933-03-01
1937-05-01, 1938-06-01
1945-02-01, 1945-10-01
1948-11-01, 1949-10-01
1953-07-01, 1954-05-01
1957-08-01, 1958-04-01
1960-04-01, 1961-02-01
1969-12-01, 1970-11-01
1973-11-01, 1975-03-01
1980-01-01, 1980-07-01
1981-07-01, 1982-11-01
1990-07-01, 1991-03-01
2001-03-01, 2001-11-01
2007-12-01, 2009-06-01"), sep=',',
  colClasses=c('Date', 'Date'), header=TRUE)

recessions.trim = subset(recessions.df, Peak >= min(index(data)) )

Phi0_temp <- coef[ , ncol(coef)]
Phi1_temp <- coef[ , 1:(ncol(coef)-1)]

z <- data_sub[ , 1:(ncol(data_sub))]
z <- as.matrix(z)
z2 <- t(z)

port_calc <- function(gamma = 5, K = 100, n= 4){
m <- nrow(Phi1_temp)

H <- diag(x = 1, m, m)

H1 <- H[1,]
H1 <- t(as.matrix(H1))

Hx <- H[2:n, ]
Hx <- as.matrix(Hx)

Phi0 <- Phi0_temp
Phi0 <- as.matrix(Phi0)

Phi1 <- Phi1_temp
Phi1 <- as.matrix(Phi1)

Phi0X <- Hx %*% Phi0
Phi1X <- Hx %*% Phi1
Phi01 <- H1 %*% Phi0
Phi11 <- H1 %*% Phi1

Sigma <- cov
SigmaXX <- Hx %*% Sigma %*% t(Hx)
SigmaX2 <- diag(SigmaXX)
SigmaX <- Hx %*% Sigma
SigmaX1 <- Hx %*% Sigma %*% t(H1)
Sigma11 <- H1 %*% Sigma %*% t(H1)

A0 <- matrix(0, nrow = n-1, ncol = 1)
A1 <- matrix(0, nrow = n-1, ncol = m)
B1 <- matrix(0, nrow = 1, ncol = m)
B2 <- matrix(0, nrow = m, ncol = m)
Lambda <- matrix(0, nrow = m, ncol = m)
Gamma <- matrix(0, nrow = m, ncol = m)
Xi <- matrix(0, nrow = m, ncol = m)

for (i in 1:(K-1)) {
  if (i==1) {
    # A0(1).
    A0 <- (1/gamma) * solve(SigmaXX) %*% (Phi0X + 1/2 * SigmaX2 + (1 - gamma) * SigmaX1)
    
    # A1(1).
    A1 <- (1/gamma) * solve(SigmaXX) %*% Phi1X
    
    # B1(1).
    B1 <- Phi11 + t(A0) %*% (Phi1X - gamma * SigmaXX %*% A1) + t(Phi0X + 1/2 * SigmaX2 + (1 - gamma) * SigmaX1) %*% A1
    
    # B2(1).
    B2 <- t(A1) %*% (Phi1X - gamma/2 * SigmaXX %*% A1)
  } else {
    
    # Gem sidste periode A0 og A1.
    A0a <- A0
    A1a <- A1
    
    # Omega.
    Omega <- solve(solve(Sigma)-2 * (1 - gamma) * B2)
    OmegaXX <- Hx %*% Omega %*% t(Hx)
    OmegaX1 <- Hx %*% Omega %*% t(H1)
    OmegaX <- Hx %*% Omega
    
    # A0.
    A0 <- solve(SigmaXX - (1 - gamma) * OmegaXX) %*% (Phi0X + 1/2 * SigmaX2 + (1 - gamma) * (OmegaX1 + OmegaX %*% (t(B1) + 2 * B2 %*% Phi0)))
    
    # A1.
    A1 <- solve(SigmaXX - (1 - gamma) * OmegaXX) %*% (Phi1X + 2 * (1 - gamma) * OmegaX %*% B2 %*% Phi1)
    
    # Lambda.
    Lambda <- B2 %*% Omega %*% t(B2)
    
    # Gamma.
    Gamma <- 2 * B2 %*% Omega
    
    # Xi.
    Xi <- t(Gamma)
    Xix <- Hx %*% Xi
    Xi1 <- H1 %*% Xi
    
    # Beregn B1 og B2 for næste periode.
    
    # B1.
    B1 <- Phi11 + t(A0a) %*% (Phi1X - (SigmaXX - (1 - gamma) * OmegaXX) %*% A1a) + t(Phi0X + 1/2 * SigmaX2 + (1 - gamma) * OmegaX1) %*% A1a + (B1 + 2 * t(Phi0) %*% B2) %*% Phi1 + (1 - gamma) * (B1 %*% t(OmegaX) + t(Phi0) %*% t(Xix)) %*% A1a + (1 - gamma) * (4 * t(Phi0) %*% Lambda + Xi1 + t(A0a) %*% Xix + B1 %*% Xi) %*% Phi1
    
    # B2.
    B2 <- t(A1a) %*% (Phi1X - gamma/2 * SigmaXX %*% A1a) + t(Phi1) %*% (B2 + 2 * (1 - gamma) * Lambda) %*% Phi1 + (1 - gamma) * t(Phi1) %*% t(Xix) %*% A1a
  }
}

if (K > 1) {
  # A0.
  A0 <- solve(SigmaXX - (1 - gamma) * OmegaXX) %*% (Phi0X + 1/2 * SigmaX2 + (1 - gamma) * (OmegaX1 + OmegaX %*% (t(B1) + 2 * B2 %*% Phi0)))
  
  # A1.
  A1 <- solve(SigmaXX - (1 - gamma) * OmegaXX) %*% (Phi1X + 2 * (1 - gamma) * OmegaX %*% B2 %*% Phi1)
  
} else {
  # A0.
  A0 <- 1/gamma * solve(SigmaXX) %*% (Phi0X + 1/2 * SigmaX2 + (1 - gamma) * SigmaX1)
  
  # A1.
  A1 <- 1/gamma * solve(SigmaXX) %*% Phi1X
}

alphafixedT <- matrix(0, nrow = n-1, ncol = ncol(z2))

for (t in (2:ncol(z2))) {
  alphafixedT[, t] <- A0 + A1 %*% z2[, t-1]
}

MyopicD <- matrix(0, nrow = n-1, ncol = ncol(z2)) 

for (K in (2:ncol(z2))) {
  MyopicD[, K] <- (1/gamma) * solve(SigmaXX) %*% (Hx %*% (Phi0 + Phi1 %*% z2[, K-1]) + 1/2 * SigmaX2 + (1-gamma) * SigmaX1)
}

HedgingD <- alphafixedT - MyopicD

TangencyP <- matrix(0, nrow = n-1, ncol = ncol(z2))

for (t in (2:ncol(z2))){
  TangencyP[, t] <- solve(SigmaXX) %*% Hx %*% (Phi0 + Phi1 %*% z2[, t-1]) + 1/2 * SigmaX2
}

GMV <- -solve(SigmaXX)%*%SigmaX1

alphafixedT <- rbind(1-colSums(alphafixedT), alphafixedT)

res_alphafixedT <- matrix(0, nrow = n, ncol = ncol(z2))

for (t in (2:ncol(z2))) {
  res_alphafixedT[, t] <- c(max(0, alphafixedT[1, t])/sum(max(0, alphafixedT[1,t]),
                                        max(0, alphafixedT[2,t]),
                                        max(0, alphafixedT[3,t]),
                                        max(0, alphafixedT[4,t])),
                            
                            max(0, alphafixedT[2, t])/sum(max(0, alphafixedT[1,t]),
                                                 max(0, alphafixedT[2,t]),
                                                 max(0, alphafixedT[3,t]),
                                                 max(0, alphafixedT[4,t])),
                            
                            max(0, alphafixedT[3, t])/sum(max(0, alphafixedT[1,t]),
                                                 max(0, alphafixedT[2,t]),
                                                 max(0, alphafixedT[3,t]),
                                                 max(0, alphafixedT[4,t])),
                            
                            max(0, alphafixedT[4, t])/sum(max(0, alphafixedT[1,t]),
                                                          max(0, alphafixedT[2,t]),
                                                          max(0, alphafixedT[3,t]),
                                                          max(0, alphafixedT[4,t]))
                          )
}

return(list(alphafixedT=alphafixedT,
            MyopicD=MyopicD,
            HedgingD=HedgingD,
            TangencyP=TangencyP,
            GMV=GMV,
            res_alphafixedT=res_alphafixedT)
       )
}

dynport <- port_calc(gamma = 5, K = 100, n = 4)

KOMP <- data.frame(Tan=c(1-sum(rowMeans(dynport$TangencyP)),
                         rowMeans(dynport$TangencyP)),
                   GMV=c(1-sum(dynport$GMV),
                         dynport$GMV),
                   Myopic=c(1-sum(rowMeans(dynport$MyopicD)),
                            rowMeans(dynport$MyopicD)),
                   IHD=c(1-sum(rowMeans(dynport$HedgingD)), rowMeans(dynport$HedgingD))
                   )

BIG_TABLE <- matrix(0, nrow = 16, ncol = 8)
BIG_R_TABLE <- matrix(0, nrow = 16, ncol = 8)

gammas <- c(2, 5, 10 , 20)
horizons <-  c(1, 4, 8, 20, 40, 60, 80, 100)
k <- 1

for (i in c(1, 5, 9, 13)) {
  for (j in (1:length(horizons))) {
    BIG_TABLE[i:(i+3), j] <- rowMeans(port_calc(gamma = gammas[k], K = horizons[j])$alphafixedT)
    BIG_R_TABLE[i:(i+3), j] <- rowMeans(port_calc(gamma = gammas[k], K = horizons[j])$res_alphafixedT)
  }
  
  k <- k+1
}

HOR_ANA_VAL <- c(1, 3:100)

HOR_ANA <- matrix(0, nrow = 4, ncol = length(HOR_ANA_VAL))
HOR_ANA_R <- matrix(0, nrow = 4, ncol = length(HOR_ANA_VAL))

for (i in (1:length(HOR_ANA_VAL))) {
  a <- port_calc(gamma = 5, K = HOR_ANA_VAL[i])
  
  HOR_ANA[, i] <- rowMeans(a$alphafixedT)
  HOR_ANA_R[, i] <- rowMeans(a$res_alphafixedT)
}

GAM_ANA_VAL <- seq(1, 50, 0.1)

GAM_ANA <- matrix(0, nrow = 4, ncol = length(GAM_ANA_VAL))
GAM_ANA_R <- matrix(0, nrow = 4, ncol = length(GAM_ANA_VAL))
GAM_ANA_MYO <- matrix(0, nrow = 4, ncol = length(GAM_ANA_VAL))

for (i in (1:length(GAM_ANA_VAL))) {
  b <- port_calc(gamma = GAM_ANA_VAL[i], K = 100)
  
  GAM_ANA[, i] <- rowMeans(b$alphafixedT)
  GAM_ANA_R[, i] <- rowMeans(b$res_alphafixedT)
  
  GAM_ANA_MYO[, i] <- rowMeans(rbind(1-colSums(b$MyopicD), b$MyopicD))
}

alpha <- xts::xts(t(dynport$alphafixedT), index(NET_TB))

colnames(alpha) <- c('A', 'B', 'C', 'D')

ggplot(alpha) +
  expand_limits(x = min(index(alpha)), y = min(alpha))+
  geom_line(aes(x=index(alpha), y=A, color = 'T-Bills', linetype = "T-Bills")) +
  geom_line(aes(x=index(alpha), y=B, color = 'Aktier', linetype = "Aktier")) +
  geom_line(aes(x=index(alpha), y=C, color = 'Statsobligationer', linetype = "Statsobligationer")) +
  geom_line(aes(x=index(alpha), y=D, color = 'Virksomhedsobligationer', linetype = "Virksomhedsobligationer")) +
  geom_rect(data=recessions.trim, aes(xmin=Peak, xmax=Trough, ymin=-Inf, ymax=+Inf), fill='pink', alpha=0.2)+
  coord_cartesian(ylim = c(min(alpha), max(alpha))) +
  scale_linetype_manual(values=c("solid", "dashed", "dotted", "dotdash"))+
  scale_x_date(expand = c(0, 0), date_labels = "%Y", date_breaks = "2 year", limits = c(min(index(alpha)), max(index(alpha))))+
  scale_y_continuous(expand=c(0,0))+
  scale_colour_brewer(palette = "Dark2") +
  theme_bw()+
  theme(
    panel.grid.minor = element_blank(),
    legend.background = element_rect(fill = "white",
                                     linetype="solid",
                                     size = 0.1,
                                     colour = "black"),
    legend.position="bottom",
    legend.key.size = unit(4, "line"),
    legend.title = element_blank(),
    legend.text=element_text(size = 20)
  ) +
  labs(color = "Aktiv",
       linetype = "Aktiv",
       shape = "Aktiv",
       size = "Aktiv")+
  xlab("År")+
  ylab("Allokering")
```

???

Hvorfor ser vi ikke allokeringerne MED rebalancering?

---

class: animated, fadeIn

# Allokering - &#128202;

Dekompositionen af *mean first-period*.

```{r, fig.retina=3, echo=FALSE, fig.align="center"}
knitr::include_graphics("C:/Users/AKF/Downloads/DEKOMP.png")
```

---

class: animated, fadeIn

# Allokering - &#128202;

Horisontanalyse og analyse af risikotolerance.

```{r, fig.retina=3, echo=FALSE, fig.align="center"}
knitr::include_graphics("C:/Users/AKF/Downloads/HORRIS.png")
```

---

class: animated, fadeIn

# Allokering - &#128202;

Kortsalgsrestriktion.

```{r, fig.retina=3, echo=FALSE, fig.align="center"}
knitr::include_graphics("C:/Users/AKF/Downloads/KORTSALG.png")
```

